#!/bin/sh

# Exit if there are any errors
set -e

if [ ! -d "/code/mysite" ]; then
  echo "Creating the Django project ..."
  cd /tmp/
  rm -rf /tmp/mysite
  /usr/bin/django-admin startproject mysite
  mv mysite/* /code/
  cd /code/
  mkdir "mysite/settings/"
  mkdir -p "media"
  mkdir -p "staticcache"
  mkdir -p "mysite/test"
  mv "mysite/settings.py" "mysite/settings/base.py"
  mv djangosharedsettings/* mysite/settings/
  mv emailbackend.py mysite/
  rm -f djangosharedsettings/.DS_Store
  rmdir djangosharedsettings
  cat << EOF >> "mysite/settings/base.py"

## Auto added by django-docker-template when the project was created
ROOT_DIR = os.path.dirname(BASE_DIR)
EOF
  cat << EOF > "mysite/settings/dev.py"
from .base_last import *

MEDIA_ROOT = os.path.join(ROOT_DIR, 'media')
MEDIA_URL = '/media/'
DEBUG = True
ALLOWED_HOSTS = ['*']
EOF
  cat << EOF > "mysite/settings/production.py"
from .production_last import *

DEBUG = os.environ.get('DEBUG', 'False').lower() == 'true'
ALLOWED_HOSTS = [host.strip() for host in os.environ['ALLOWED_HOSTS'].split(',')]
PREPEND_WWW = os.environ.get('PREPEND_WWW', 'false').strip().lower() == 'true'
EOF
  cat << EOF >> "mysite/urls.py"
# Set up dev static erver
from django.conf import settings

if settings.DEBUG:
    from django.conf.urls.static import static
    from django.contrib.staticfiles.urls import staticfiles_urlpatterns

    # Serve static and media files from development server
    urlpatterns += staticfiles_urlpatterns()
    urlpatterns += static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT)
EOF
  cat mysite/settings/urls_08_allauth.py >> "mysite/urls.py"
  rm mysite/settings/urls_08_allauth.py
  # We need the allauth URLs first, because they should be used in preference to the Wagtail equivalents
  cat mysite/settings/urls_09_wagtail.py >> "mysite/urls.py"
  rm mysite/settings/urls_09_wagtail.py
  mv templates mysite/
  mkdir -p "mysite/static/css" "mysite/static/js"
  cat << EOF > "mysite/static/css/styles.css"
.messages {
    background-color: #CCC;
}
EOF
  cat << EOF > "mysite/static/js/scripts.js"
// var elem = document.createElement('div');
// elem.innerHTML = 'JS working';
// document.body.appendChild(elem);
console.log('JS working');
EOF
  cat << EOF >> "mysite/test/test.py"
import json
import os
from django.test import TestCase
from selenium import webdriver
from selenium.webdriver.common.by import By
import time

from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC

class ExampleTests(TestCase):

    @classmethod
    def setUpClass(cls):
        super().setUpClass()
        cls.browser = webdriver.Remote(
            command_executor='http://chrome:4444/wd/hub',
            desired_capabilities={'browserName': 'chrome', 'javascriptEnabled': True})
        cls.browser.implicitly_wait(0)

    @classmethod
    def tearDownClass(cls):
        # Comment this out if you don't want Chrome to quit
        cls.browser.quit()
        # Handy to use this line for debugging
        # import pdb; pdb.set_trace()
        super().tearDownClass()

    def test_01_get_debug_root(self):
        self.browser.get('http://web:8000/')
        heading = WebDriverWait(self.browser, 20).until(
            EC.presence_of_element_located((By.CSS_SELECTOR, 'h1'))
        )
        self.assertEqual(heading.text, "Page not found (404)")
EOF
  echo "done."
fi

python3 manage.py collectstatic --noinput
. run.common

echo "Binding to $PORT"
python3 manage.py runserver "0.0.0.0:$PORT"

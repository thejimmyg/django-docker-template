# mysite

## Development

1. Install the latest version of Docker

   On most platforms this just means going to the Docker website and running
   the installer for your platform. Docker compose should be included.

   On a raspberry pi this can be done with:

   ```
   curl -fsSL https://get.docker.com -o get-docker.sh
   sh get-docker.sh
   sudo apt install -y python3 python3-pip python3-dev
   sudo pip3 install docker-compose
   ```

2. Clone the repo to a directory called `mysite` (if you choose a different
   name, Docker Compose will name the containers in a different way to the names
   used in the documentation).

3. Copy `docker-compose.yml.example` to `docker-compose.yml` and update it with
   the settings you want to use for development

   ```
   cp docker-compose.yml.example docker-compose.yml
   ```

4. Start the `web` and `db` containers:

   ```
   docker-compose down && COMPOSE_DOCKER_CLI_BUILD=1 DOCKER_BUILDKIT=1 docker-compose up --build web db && docker-compose logs -f web db
   ```

   Note: On an older raspberry pi you might need to increase the timeouts by also
   setting `COMPOSE_HTTP_TIMEOUT=220 DOCKER_CLIENT_TIMEOUT=220` before
   `COMPOSE_DOCKER_CLI_BUILD=1`.

   The `web` container is build using the experimental BuildKit front end to cache
   the pip downloads so that if you change your `base-requirements.txt` file you
   don't have to re-download all the requirements, only the ones that have
   changed. This needs a recent version of Docker Compose e.g. 1.25.4. If you
   don't have this, follow the comments in `web/Dockerfile` to take a different
   approach without the caching.

   Your will be hosted then at http://localhost:8000 (the port may be different if
   you configured a different `PORT` variable).

   Optionally you can run `docker-compose build awscli gitcli` to build those
   containers. This could be useful if you don't have `git` installed and wish to
   use it, or if you intend to use the `aws` command and don't have that
   installed.

5. Set up aliases

   It can be a bit tedious typing the full `docker-compose` commands you need, so
   you can alias them to shorter versions. You'll need to do this each time you
   start working in a new terminal.

   ```
   alias mysite_manage.py="docker-compose -f `pwd`/docker-compose.yml run --rm web python3 manage.py"
   alias mysite_autopep8="docker-compose -f `pwd`/docker-compose.yml run --rm web /usr/bin/autopep8"
   alias mysite_psql="docker-compose -f `pwd`/docker-compose.yml run --rm db psql"
   # For CLIs
   # alias mysite_git="docker-compose -f `pwd`/docker-compose.yml run --rm gitcli"
   # alias mysite_aws="docker-compose -f `pwd`/docker-compose.yml run --rm awscli"
   # For geo:
   # alias mysite_ogrinfo="docker-compose -f `pwd`/docker-compose.yml run --rm web ogrinfo"
   # alias mysite_ogrinspect="docker-compose -f `pwd`/docker-compose.yml run --rm web ogrinspect"
   ```

   The commands above all start new containers. If you happen to have the
   container running already it can be more efficient to exec the command in the
   currently running container. Set up these aliases too:

   Note: If the directory containing this one is not named `mysite` then you'll
   need to adjust the prefix of each of the container names.

   ```
   alias mysite_running_manage.py="docker exec -it mysite_web_1 python3 manage.py"
   alias mysite_running_web_sh="docker exec -it mysite_web_1 /bin/sh"
   alias mysite_running_autopep8="docker exec -it mysite_web_1 /usr/bin/autopep8"
   alias mysite_running_psql="docker exec -it mysite_db_1 psql"
   # For geo:
   # alias mysite_running_ogrinfo="docker exec mysite_web_1 ogrinfo"
   # alias mysite_running_ogrinspect="docker exec mysite_web_1 ogrinspect"
   ```

6. Set up the database:

   You can use your new `manage.py` alias or `running_manage.py`:

   ```
   # Checks there are no migrations to be created (there shouldn't be if you've made no changes yet)
   mysite_running_manage.py makemigrations
   # Set up the database
   mysite_running_manage.py migrate
   # Change the default site to serve from port 8000 (which is the port the `web` container uses internally.
   mysite_running_manage.py loaddata mysite/settings/base_09_wagtail_site.json
   # Set up the default theme for Wagtail
   mysite_running_manage.py loaddata mysite/settings/base_09_wagtail_theme.json
   ```

7. Create a superuser

   This is a bit tricky because you want your superuser to be able to sign in with
   AllAuth so that you can disable all the other login screens like the Django
   admin or Wagtail CMS ones. This disabling is currently done with the redirects
   to /accounts/login that are set up in `mysite/urls.py`.

   You can work around this by enabling the admin, registering a user via the web
   interface, verifying the email, creating a superuser on the command line, using
   this second user to login to the admin to give the first user staff and
   superuser permissions, then loging back in as the first user to delete the
   second one.

   It is much easier to load a fixture, login and then change the email and
   password. You can do this like this:

   ```
   mysite_running_manage.py loaddata mysite/settings/base_08_user.json
   ```

   This creates a user with `me@example.com` as the email and the password
   `123123ab`. You can use it to log in to the admin at `/admin` and change the
   email in AUTHENTICATION AND AUTHORIZATION -> Users.

### Notes

Note the Wagtail page you see as the homepage comes directly from `Page` class
which you won't use in future. You'll use a `HomePage` model instead that will
use the same base template as other pages. Because you loaded the
`base_09_wagtail_theme.json` fixture, the site is set up to use the `Default`
theme in `mysite/templates/theme/` which overrides `wagtailcore/page.html` to
use `base.html`. `base.html` overriden itself in this theme to provide Home and
Login links.

When you login to /cms you can change the theme in Settings->Theme.

You can connect to the PostgreSQL database using the `psql` command you aliased
above which really runs in your `db` container:

```
mysite_running_psql -h db -U postgres postgres
```

In development remember to clear your browser cache once you've changed static
files and run `mysite_running_manage.py collectstatic` by restarting the Docker
container. Otherwise the browser will use the cached old version.


### Starting an app

You should do all your development in separate Django apps rather than in the
generated project. This is Django best practice.

With your aliases set up, create an app with:

```
mysite_running_manage.py startapp myapp
```

### Customise User Model

If you want to extend the `User` model, the best way is by creating a new model
named something like `Profile` with a `ForeignKey` to `User` rather than
deriving a new model from `AbstractUser`. Then you can just access the fields
using `request.user.profile` and it doesn't interfere with the way anything
else uses the `User` model.

### Syntax Formatting

Make sure the alias is set up as described above, then run `autopep8` from
within the container like this:

```
runnning_autopep8 --diff --exclude /code/mysite/settings/base.py -r /code/
runnning_autopep8 --in-place --exclude /code/mysite/settings/base.py -r /code/
```

### Running Tests

Once you've written tests, you can run them like this:

```
docker-compose up -d chrome
mysite_running_manage.py test --failfast -k mysite/test
```

You can use VNC Viewer to view Chrome while the tests are running.

https://www.realvnc.com/en/connect/download/viewer/

Load the viewer and enter the address `localhost:5900` while the `chrome`
docker container is running to see the testing visaully in browser. You'll need
to ignore the warning about the connection being unencrypted. Then enter the
password `secret`.

### Production


You can now deploy to:

* A bare metal server (e.g. a Raspberry Pi, Rack Mount Server or a spare laptop)
* AWS
* Heroku (using some AWS services like S3 and SES)

Heroku will expect an app called `mysite-staging` to be created, along with a
free PostgreSQL instance.

For production the following variables must set up:

* `ADMINS` - a comma-separated list of emails to receive error reports
* `ALLOWED_HOSTS` - a comma-separated list of allowed hosts
* `DATABASE_URL` - The database settings. This is set up by Heroku.
* `DJANGO_SETTINGS_MODULE` - `mysite.settings.production`
* `SECRET_KEY` -  a long (32 characters+) random string used for deriving secrets for the session cookies and other things

It is important you set:

```
DJANGO_SETTINGS_MODULE: mysite.settings.production
```

This sets up some extra features and security and disables the reloading dev server.

It will also expect the site to be served behind an SSL proxy such as Nginx (or
the one Heroku provides). If you try to access it directly, it will issue an
redirect to HTTPS which will probably fail silently in browsers and command
line tools.

Also, change the the password for `POSTGRES_PASSWORD` in `db` and `DATABASE_URL` in `web`.

Finally, change the command from `run.sh.dev` to `run.sh` to change the server to gunicorn for production:

```
command: /bin/sh /code/run.sh
```

This is also the default command that gets run when the Docker container is started directly if you are not using `docker-compose` e.g. on Heroku.

Note that when use `run.sh` instead of `run.sh.dev`, the Gunicorn server with
Gevent is used to serve Django instead of the Django development server. This
means the server will no longer re-start when you make changes. You'll have to
restart the container if running via docker-compose or rebuild and restart if
using Docker without the volume mounts.

Also, in production mode the assets that are linked to are the ones that
contain a checksum in the file name making them suitable to be served with a
far future expiry date.

Heroku and AWS deployments both assume that you will use an S3 bucket for static files.

For media in production on Heroku you'll need to create an S3 bucket with suitable
permissions as described in `web/djangosharedsettings/production_01_bucket.py` then set:

* `AWS_STORAGE_BUCKET_NAME` - The name of the S3 bucket
* `AWS_ACCESS_KEY_ID` - The access key ID for the bucket above
* `AWS_SECRET_ACCESS_KEY` - The secret key for the access key above

Usually you'll set up AWS SES as an SMTP email server. You'll also need to
uncomment the AWS requirements in `web/requirements.txt` and re-build the
container.

For email you can use the variables in `web/djangosharedsettings/base_02_email.py`. At the moment the system will use the first email specified in `ADMINS`:

* `EMAIL_PORT` - e.g. `465`
* `EMAIL_USE_TLS` - e.g. `"false"`
* `EMAIL_USE_SSL` - e.g. `"true"`
* `SERVER_EMAIL` - e.g. `admin@mysite.example.com`
* `DEFAULT_FROM_EMAIL` - e.g. `admin@mysite.example.com`
* `EMAIL_HOST` - e.g. `smtp.example.com`
* `EMAIL_HOST_PASSWORD`
* `EMAIL_HOST_USER`

For instructions on how to set up SES and for test email sending see `EMAIL.md`.

Once this is done, check out HEROKU.md for Heroku instructions or EC2.md for EC2 instructions.

## Nginx in Production


* Uncomment nginx lines in `docker-compose.yml`
* Make sure you update `LETS_ENCRYPT_EMAIL` to the real email address of a person who has agreed to the terms and conditions of Let's Encryp

  ```
  nginx:
    ...
    environment:
      LETS_ENCRYPT_EMAIL: "james@example.com"
  ```

* Put Django into production by changing the settings module and using `run.sh`

  ```
  ...
  web:
    ...
    environment:
      DJANGO_SETTINGS_MODULE: test2.settings.production
      ...
    command: /bin/sh /code/run.sh
  ```

* Make sure your live DNS on the internet points to the server you want a certificate for and that the domain is in `ALLOWED_HOSTS` in the `web` section of your `docker-compose.yml`:

  ```
  ...
  web:
    ...
    environment:
      ALLOWED_HOSTS: www.example.com,example.com
  ```


* Apply your Docker Compose changes with:

  ```
  docker-compose down && COMPOSE_DOCKER_CLI_BUILD=1 DOCKER_BUILDKIT=1 docker-compose up --build nginx web db && docker-compose logs -f nginx web db
  ```

* Set up your Nginx shell alias and start the shell:

  ```
  alias test2_running_nginx_sh="docker exec -it test2_nginx_1 sh"
  test2_running_nginx_sh
  ```

* Set up the new domain, get the certificate and install it using the `new-domain` command. This takes the domain (without `www.`) then the internal Docker name of the machine you want to proxy to, then the port to on that machine. In this case you want to proxy to your Django app running in `web` on port 8000. NOTE: You must not specify `www.` in the command as this will be added automatically. Type `exit` to exit the shell when you are done.

  ```
  new-domain example.com web 8000
  ```


NOTE: For testing you can edit /bin/new-domain and follow the instructions in
the comment to add the `--server` flag to the `lego` commands to use the
staging server.


## Backup and Restore

It is possible to backup and restore data at the Django level rather than the PostgreSQL level if you like. Here's an example:

```
manage.py dumpdata --indent 2 --format json --natural-foreign --natural-primary > dump.json
```

Not reset the database, and run the migrations again to set up the tables:

```
manage.py migrate
```

Now restore the data from the dump:

```
cat dump.json | manage.py loaddata --format=json -
```

## Stats

In production mode this is representative of the resource usage:

```
$ docker stats
CONTAINER ID        NAME                CPU %               MEM USAGE / LIMIT     MEM %               NET I/O             BLOCK I/O           PIDS
11dd70e4d2d8        mysite_db_1          0.03%               4.277MiB / 1.943GiB   0.21%               24.8kB / 18.3kB     0B / 0B             7
669c9cd2b4c5        mysite_nginx_1       0.01%               5.73MiB / 1.943GiB    0.29%               64kB / 75.5kB       0B / 0B             8
c8e0ba252d01        mysite_web_1         0.03%               70.97MiB / 1.943GiB   3.57%               28.8kB / 32.5kB     0B / 0B             2

$ docker images | egrep '(mysite|postgres)'
mysite_nginx                                    latest              7c6eece7401b        6 minutes ago       53.9MB
mysite_web                                      latest              28fd39f3e355        30 minutes ago      260MB
mysite_db                                       12-alpine           ecb176ff304a        10 days ago         151MB
```
